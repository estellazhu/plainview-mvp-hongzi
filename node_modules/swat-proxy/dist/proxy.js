'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.proxy = proxy;
exports.proxyMultiple = proxyMultiple;
exports.removeProxy = removeProxy;
exports.deliverWebpage = deliverWebpage;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

var _injector = require('./injector');

var injector = _interopRequireWildcard(_injector);

var _logger = require('./logger');

var logger = _interopRequireWildcard(_logger);

var _enums = require('./enums');

var _utils = require('./utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Members.


// Local.
/**
 * Creates a proxy server.
 */

// Core.
const DEFAULT_PORT = 8068;

// NPM.

const ERROR_MISSING_PARAMS = 'Missing one or more required parameters';

/**
 * Adds a proxy target.
 *
 * @param {String}  target  - A string to test URLs against.
 *   If the URL matches according to its options.matchType rule,
 *   options.content will be injected into the response.
 *
 * @param {Object | Array}  options - Required options or list of options.
 *
 * @param {String}  options.selector - The cheerio selector to use.
 *   @see https://github.com/cheeriojs/cheerio#selectors
 *
 * @param {String}  options.manipulation - The cheerio manipulation method to use.
 *   @see enums.js.
 *
 * @param {String}  options.content - The HTML / CSS / JS content to inject.
 *
 * @returns {void}
 */
function proxy(target, options) {
  // A target is required.
  if (!target) {
    throw new Error(`${ERROR_MISSING_PARAMS}: 'url'`);
  }

  // Lowercase our target url for storage
  target = (0, _utils.trimSlash)(target.toLowerCase());

  const defaultMatchType = _enums.MatchTypes.EXACT;

  // Ensure that options is an array.
  options = [].concat(options);
  const missingOptions = [];

  for (let optionEntry of options) {
    if (!optionEntry.selector) {
      missingOptions.push('selector');
    }
    if (!optionEntry.manipulation) {
      missingOptions.push('manipulation');
    }
    if (!optionEntry.content) {
      missingOptions.push('content');
    }

    optionEntry.matchType = optionEntry.matchType || defaultMatchType;

    // All options parameters are required.
    if (missingOptions.length > 0) {
      throw new Error(`${ERROR_MISSING_PARAMS}: '${missingOptions.join('\', \'')}'`);
    }

    // Add the desired proxy target.
    injector.addProxyTarget(target, optionEntry);
  }
}

function proxyMultiple(targets, options) {
  // A target is required.
  if (!targets) {
    throw new Error(`${ERROR_MISSING_PARAMS}: 'url'`);
  }

  // Lowercase our target url for storage
  targets.forEach(function(target){
    target = (0, _utils.trimSlash)(target.toLowerCase());
  });

  const defaultMatchType = _enums.MatchTypes.EXACT;

  // Ensure that options is an array.
  options = [].concat(options);
  const missingOptions = [];

  for (let optionEntry of options) {
    if (!optionEntry.selector) {
      missingOptions.push('selector');
    }
    if (!optionEntry.manipulation) {
      missingOptions.push('manipulation');
    }
    if (!optionEntry.content) {
      missingOptions.push('content');
    }

    optionEntry.matchType = optionEntry.matchType || defaultMatchType;

    // All options parameters are required.
    if (missingOptions.length > 0) {
      throw new Error(`${ERROR_MISSING_PARAMS}: '${missingOptions.join('\', \'')}'`);
    }

    // Add the desired proxy target.
    targets.forEach(function(target){
      injector.addProxyTarget(target, optionEntry);
    });
  }
}

/**
 * Removes a proxy target.
 *
 * @param {String}  target  - A string to test URLs against.
 *
 * @param {Object | Array}  options - options to be removed, or list of options to be removed.
 *
 * @returns {void}
 */
function removeProxy(target, options) {
  // A target is required.
  if (!target) {
    throw new Error(`${ERROR_MISSING_PARAMS}: 'url'`);
  }

  // Lowercase our target url for comparison to storage
  target = (0, _utils.trimSlash)(target.toLowerCase());

  if (options) {
    // Ensure that options is an array.
    options = [].concat(options);

    for (let optionEntry of options) {
      // Remove the desired proxy target.
      injector.removeProxyTarget(target, optionEntry);
    }
  } else {
    injector.removeProxyTarget(target);
  }
}

/**
 * Creates and starts the proxy server.
 *
 * @param {Object}  options - Optional options.
 *
 * @param {Number}  options.port - The port to start the proxy server on.
 *                               Defaults to 8063.
 *
 * @param {Boolean} options.debugMode - Enables logging to help debug problems.
 *
 * @returns {void}
 */
function deliverWebpage(options, clientResponse, url) {
  // Enable the logger if requested to do so.

  // Actually make the request to the desired endpoint to get the initial HTML.
  (0, _request2.default)({
    url: url,
    encoding: null
  }, (err, response, endpointHTML) => {
    // Possibly inject things into this response.
    let alteredResponse = endpointHTML;

    if (endpointHTML) {
      alteredResponse = injector.injectInto(url, endpointHTML);
    }

    // Preserve the server headers.
    if (response && response.headers) {
      for (let header in response.headers) {
        clientResponse.setHeader(header, response.headers[header]);
      }
    }

    // Send the possibly modified response back to the client.
    clientResponse.end(alteredResponse);
  });
}